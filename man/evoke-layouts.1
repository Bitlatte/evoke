.\" Automatically generated by Pandoc 3.7.0.2
.\"
.TH "" "" "" ""
.SH Layouts
Evoke uses a simple yet powerful layout system to help you create
consistent page structures for your site.
Layouts are defined using \f[CR]_layout.html\f[R] files, and they allow
you to define a common structure for a set of pages.
.SS The \f[CR]_layout.html\f[R] File
A layout is an HTML file that contains the basic structure of a page.
It typically includes the \f[CR]<html>\f[R], \f[CR]<head>\f[R], and
\f[CR]<body>\f[R] tags, as well as any other common elements that you
want to appear on every page, such as a header, footer, or navigation
bar.
.PP
The key to a layout file is the \f[CR]{{ .Content }}\f[R] variable.
This is where the content of the individual pages will be injected.
.SS Example
Here\(cqs an example of a basic layout file:
.PP
\f[CR]content/_layout.html\f[R]:
.IP
.EX
<!DOCTYPE html>
<\f[B]html\f[R] lang=\(dqen\(dq>
<\f[B]head\f[R]>
  <\f[B]meta\f[R] charset=\(dqUTF\-8\(dq>
  <\f[B]title\f[R]>{{ .Page.title }}</\f[B]title\f[R]>
</\f[B]head\f[R]>
<\f[B]body\f[R]>
  <\f[B]header\f[R]>
    <\f[B]h1\f[R]>{{ .Global.siteName }}</\f[B]h1\f[R]>
  </\f[B]header\f[R]>

  <\f[B]main\f[R]>
    {{ .Content }}
  </\f[B]main\f[R]>

  <\f[B]footer\f[R]>
    <\f[B]p\f[R]>&copy; 2024 {{ .Global.siteName }}</\f[B]p\f[R]>
  </\f[B]footer\f[R]>
</\f[B]body\f[R]>
</\f[B]html\f[R]>
.EE
.PP
In this example, \f[CR]{{ .Page.title }}\f[R] will be replaced with the
title from the page\(cqs front matter, and
\f[CR]{{ .Global.siteName }}\f[R] will be replaced with the site name
from the \f[CR]evoke.yaml\f[R] file.
.SS Hierarchical Layouts
Evoke\(cqs layout system is hierarchical.
When rendering a page, Evoke will look for a \f[CR]_layout.html\f[R]
file in the same directory as the page.
If it doesn\(cqt find one, it will look in the parent directory, and so
on, all the way up to the \f[CR]content\f[R] directory.
.PP
This allows you to create a default layout for your entire site, and
then override it for specific sections.
.SS Example
Consider the following directory structure:
.IP
.EX
content/
├── _layout.html
└── blog/
    ├── _layout.html
    └── post\-1.md
.EE
.PP
In this example, \f[CR]post\-1.md\f[R] will be rendered using the
\f[CR]blog/_layout.html\f[R] file.
If \f[CR]blog/_layout.html\f[R] didn\(cqt exist, it would be rendered
using \f[CR]content/_layout.html\f[R].
.SS Nested Layouts
Layouts can also be nested.
This is useful for creating complex page structures with multiple levels
of inheritance.
.SS Example
Let\(cqs say you have a base layout for your entire site, and then a
separate layout for your blog that adds a sidebar.
.PP
\f[CR]content/_layout.html\f[R]:
.IP
.EX
<!DOCTYPE html>
<\f[B]html\f[R] lang=\(dqen\(dq>
<\f[B]head\f[R]>
  <\f[B]title\f[R]>{{ .Page.title }}</\f[B]title\f[R]>
</\f[B]head\f[R]>
<\f[B]body\f[R]>
  {{ .Content }}
</\f[B]body\f[R]>
</\f[B]html\f[R]>
.EE
.PP
\f[CR]content/blog/_layout.html\f[R]:
.IP
.EX
<\f[B]div\f[R] class=\(dqcontainer\(dq>
  <\f[B]main\f[R] class=\(dqmain\-content\(dq>
    {{ .Content }}
  </\f[B]main\f[R]>
  <\f[B]aside\f[R] class=\(dqsidebar\(dq>
    <\f[B]h2\f[R]>Recent Posts</\f[B]h2\f[R]>
    <\f[B]ul\f[R]>
      <\f[B]li\f[R]>Post 1</\f[B]li\f[R]>
      <\f[B]li\f[R]>Post 2</\f[B]li\f[R]>
    </\f[B]ul\f[R]>
  </\f[B]aside\f[R]>
</\f[B]div\f[R]>
.EE
.PP
When \f[CR]post\-1.md\f[R] is rendered, its content will first be
injected into \f[CR]content/blog/_layout.html\f[R] in place of
\f[CR]{{ .Content }}\f[R].
Then, the \f[I]entire result\f[R] of that will be injected into
\f[CR]content/_layout.html\f[R] in place of its
\f[CR]{{ .Content }}\f[R].
