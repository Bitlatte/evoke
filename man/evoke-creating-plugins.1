.\" Automatically generated by Pandoc 3.7.0.2
.\"
.TH "" "" "" ""
.SH Creating Plugins
This guide will walk you through the process of creating your first
Evoke plugin.
We\(cqll create a simple plugin that prints a message during the build
process.
.SS Prerequisites
Before you begin, make sure you have the following installed:
.IP \(bu 2
Go
.IP \(bu 2
Protobuf Compiler (\f[CR]protoc\f[R])
.IP \(bu 2
Go gRPC plugins
.PP
You can install the Protobuf Compiler and the Go gRPC plugins with the
following commands:
.IP
.EX
brew install protobuf
go install google.golang.org/protobuf/cmd/protoc\-gen\-go\(atv1.28
go install google.golang.org/grpc/cmd/protoc\-gen\-go\-grpc\(atv1.2
.EE
.SS Step 1: Create a New Directory
First, create a new directory for your plugin inside your project\(cqs
\f[CR]plugins\f[R] directory.
For this example, we\(cqll create a \f[CR]hello\f[R] plugin.
.IP
.EX
mkdir \-p plugins/hello
.EE
.SS Step 2: Create the Plugin File
Inside the \f[CR]plugins/hello\f[R] directory, create a new file named
\f[CR]main.go\f[R].
This file will contain the code for your plugin.
.IP
.EX
\f[B]package\f[R] main

\f[B]import\f[R] (
    \(dqcontext\(dq
    \(dqfmt\(dq

    \(dqgithub.com/Bitlatte/evoke/pkg/plugins\(dq
    \(dqgithub.com/Bitlatte/evoke/proto\(dq
    \(dqgithub.com/hashicorp/go\-plugin\(dq
)

\f[I]// Here is a real implementation of the plugin.\f[R]
\f[B]type\f[R] HelloPlugin \f[B]struct\f[R]{}

\f[B]func\f[R] (p *HelloPlugin) OnPreBuild(ctx context.Context, req *proto.OnPreBuildRequest) (*proto.OnPreBuildResponse, error) {
    fmt.Println(\(dqHello from the OnPreBuild hook!\(dq)
    \f[B]return\f[R] &proto.OnPreBuildResponse{}, nil
}

\f[B]func\f[R] (p *HelloPlugin) OnConfigLoaded(ctx context.Context, req *proto.OnConfigLoadedRequest) (*proto.OnConfigLoadedResponse, error) {
    fmt.Println(\(dqHello from the OnConfigLoaded hook!\(dq)
    \f[B]return\f[R] &proto.OnConfigLoadedResponse{Config: req.Config}, nil
}

\f[B]func\f[R] (p *HelloPlugin) OnPublicAssetsCopied(ctx context.Context, req *proto.OnPublicAssetsCopiedRequest) (*proto.OnPublicAssetsCopiedResponse, error) {
    fmt.Println(\(dqHello from the OnPublicAssetsCopied hook!\(dq)
    \f[B]return\f[R] &proto.OnPublicAssetsCopiedResponse{}, nil
}

\f[B]func\f[R] (p *HelloPlugin) OnContentLoaded(ctx context.Context, req *proto.OnContentLoadedRequest) (*proto.OnContentLoadedResponse, error) {
    fmt.Printf(\(dqHello from the OnContentLoaded hook for %s!\(rsn\(dq, req.Path)
    \f[B]return\f[R] &proto.OnContentLoadedResponse{Content: req.Content}, nil
}

\f[B]func\f[R] (p *HelloPlugin) OnContentRender(ctx context.Context, req *proto.OnContentRenderRequest) (*proto.OnContentRenderResponse, error) {
    fmt.Printf(\(dqHello from the OnContentRender hook for %s!\(rsn\(dq, req.Path)
    \f[B]return\f[R] &proto.OnContentRenderResponse{Content: req.Content}, nil
}

\f[B]func\f[R] (p *HelloPlugin) OnHTMLRendered(ctx context.Context, req *proto.OnHTMLRenderedRequest) (*proto.OnHTMLRenderedResponse, error) {
    fmt.Printf(\(dqHello from the OnHTMLRendered hook for %s!\(rsn\(dq, req.Path)
    \f[B]return\f[R] &proto.OnHTMLRenderedResponse{Content: req.Content}, nil
}

\f[B]func\f[R] (p *HelloPlugin) OnPostBuild(ctx context.Context, req *proto.OnPostBuildRequest) (*proto.OnPostBuildResponse, error) {
    fmt.Println(\(dqHello from the OnPostBuild hook!\(dq)
    \f[B]return\f[R] &proto.OnPostBuildResponse{}, nil
}

\f[B]func\f[R] main() {
    plugin.Serve(&plugin.ServeConfig{
        HandshakeConfig: plugins.Handshake,
        Plugins: \f[B]map\f[R][string]plugin.Plugin{
            \(dqevoke\(dq: &plugins.EvokePlugin{Impl: &HelloPlugin{}},
        },
        GRPCServer: plugin.DefaultGRPCServer,
    })
}
.EE
.SS Step 3: Build the Plugin
To build the plugin, run the following command from your project\(cqs
root directory:
.IP
.EX
go build \-o plugins/hello/hello plugins/hello/main.go
.EE
.PP
This will create a new executable file named \f[CR]hello\f[R] in your
\f[CR]plugins/hello\f[R] directory.
This is the compiled plugin that Evoke will load.
.SS Step 4: Run a Build
Now that your plugin is built, run the \f[CR]evoke build\f[R] command:
.IP
.EX
evoke build
.EE
.PP
You should see the messages from your plugin printed to the console
during the build process.
