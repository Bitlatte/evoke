.\" Automatically generated by Pandoc 3.7.0.2
.\"
.TH "" "" "" ""
.SH Contributing Code
If you\(cqre a developer, you can contribute to the project by writing
code.
To get started, you\(cqll need to fork the \c
.UR https://github.com/Bitlatte/evoke
Evoke repository
.UE \c
\ on GitHub and clone it to your local machine.
.SS Development Workflow
.IP "1." 3
Create a new branch for your changes.
.IP "2." 3
Make your changes and commit them with a clear and descriptive message.
.IP "3." 3
Push your changes to your fork.
.IP "4." 3
Create a pull request to the \f[CR]main\f[R] branch of the Evoke
repository.
.PP
When creating a pull request, please include a detailed description of
your changes and any relevant information that will help us to review
them.
.SS Code Style
We use the standard Go code style, so please make sure your code is
formatted with \f[CR]gofmt\f[R] before submitting a pull request.
We also use \f[CR]golangci\-lint\f[R] to lint our code, so please make
sure your code passes all of the linter checks.
.SS Testing
We have a comprehensive test suite that we use to ensure the quality of
our code.
Before submitting a pull request, please make sure that all of the tests
pass.
You can run the tests with the following command:
.IP
.EX
go test ./...
\f[I]# Reporting Bugs\f[R]

If you find a bug in Evoke, please report it so we can fix it. The best way to report a bug is to create a new issue on our [GitHub repository]\f[B](\f[R]https://github.com/Bitlatte/evoke/issues\f[B])\f[R].

When reporting a bug, please include the following information:

\-   A clear and descriptive title.
\-   A detailed description of the bug, including the steps to reproduce it.
\-   The version of Evoke you are using.
\-   The operating system you are using.
\-   Any relevant error messages or logs.

This information will help us to quickly identify and fix the bug.
\f[I]# Suggesting Features\f[R]

We\(aqre always looking for new ideas to improve Evoke. If you have an idea for a new feature, we\(aqd love to hear it. The best way to suggest a feature is to create a new issue on our [GitHub repository]\f[B](\f[R]https://github.com/Bitlatte/evoke/issues\f[B])\f[R].

When suggesting a feature, please include the following information:

\-   A clear and descriptive title.
\-   A detailed description of the feature, including the problem it solves and how it would work.
\-   Any relevant examples or mockups.

This information will help us to understand your idea and determine if it\(aqs a good fit for the project.
# Writing Documentation

We\(aqre always looking for help with writing and improving our documentation. If you\(aqre interested in helping out, you can start by forking the [Evoke repository](https://github.com/Bitlatte/evoke) on GitHub and cloning it to your local machine.

All of our documentation is written in Markdown and is located in the \(gadocs/content\(ga directory.

## Documentation Style

When writing documentation, please try to follow these guidelines:

\-   Use clear and concise language.
\-   Use examples to illustrate your points.
\-   Use a consistent tone and style.
\-   Use proper grammar and spelling.

## Submitting Changes

When you\(aqre ready to submit your changes, please create a pull request to the \f[B]\(ga\f[R]main\f[B]\(ga\f[R] branch of the Evoke repository. In your pull request, please include a detailed description of your changes and any relevant information that will help us to review them.
\f[I]# Build Process\f[R]

When you run \f[B]\(ga\f[R]evoke build\f[B]\(ga\f[R], the following steps are performed:

1.  **Load Configuration:** Evoke loads the configuration from the \f[B]\(ga\f[R]evoke.yaml\f[B]\(ga\f[R] file. This file contains all of the settings for your project, such as the name of your site, the URL of your site, and any custom data that you want to make available to your templates.

2.  **Create Output Directory:** Evoke creates the \f[B]\(ga\f[R]dist\f[B]\(ga\f[R] directory if it doesn\(aqt already exist. This is where your static site will be generated.

3.  **Copy Public Directory:** Evoke copies the contents of the \(gapublic\(ga directory to the \(gadist\(ga directory. This is where you should put any static assets that you want to be copied to your site, such as images, CSS files, and JavaScript files.

4.  **Load Partials:** Evoke loads any partials from the \(gapartials\(ga directory. Partials are small snippets of HTML that can be reused across multiple pages. For example, you might have a partial for your site\(aqs header and another for your site\(aqs footer.

5.  **Load Plugins:** Evoke loads any plugins from the \(gaplugins\(ga directory. Plugins are small programs that can be used to extend the functionality of Evoke. For example, you could use a plugin to add support for a new templating language or to add a custom build step.

6.  **Run OnPreBuild Hooks:** Evoke runs the \(gaOnPreBuild\(ga hook for each loaded plugin. This allows plugins to perform any necessary setup before the build process begins.

7.  **Run OnConfigLoaded Hooks:** Evoke runs the \(gaOnConfigLoaded\(ga hook for each loaded plugin. This allows plugins to modify the configuration before it is used.

8.  **Run OnPublicAssetsCopied Hooks:** Evoke runs the \(gaOnPublicAssetsCopied\(ga hook for each loaded plugin. This allows plugins to perform actions after the public assets have been copied.

9.  **Process Content:** Evoke processes all of the content in the \(gacontent\(ga directory. This is where you should put all of the pages for your site. Evoke supports both Markdown and HTML files.

10. **Run OnPostBuild Hooks:** Evoke runs the \(gaOnPostBuild\(ga hook for each loaded plugin. This allows plugins to perform any necessary cleanup after the build process is complete.

## Incremental Builds

To improve build times, Evoke uses an incremental build process. This means that it only rebuilds files that have changed since the last build. This is accomplished by storing a cache of file hashes in memory.

When you run \(gaevoke build\(ga, Evoke first builds a dependency graph of all the files in your \(gacontent\(ga and \(gapartials\(ga directories. It then compares the hashes of the files in the dependency graph to the hashes in the cache. If a file\(aqs hash has changed, or if the file is not in the cache, Evoke will rebuild the file and any files that depend on it.

This process is completely automatic and requires no configuration. However, if you ever need to force a full rebuild, you can do so by running the build with the \f[B]\(ga\f[R]\-\-clean\f[B]\(ga\f[R] flag.
\f[I]# Configuration\f[R]

Evoke is designed to work with zero configuration, but you can customize your project by creating an \f[B]\(ga\f[R]evoke.yaml\f[B]\(ga\f[R] file in the root directory.

\f[I]## The \(gaevoke.yaml\(ga File\f[R]

This file is entirely optional. If you\(aqre happy with Evoke\(aqs default settings, you don\(aqt need it. However, if you want to customize your site, this is the place to do it.

The \(gaevoke.yaml\(ga file uses the YAML format, which is easy to read and write. You can add any key\-value pairs you need, and they will be available in your templates.

### Example

Here\(aqs an example of a more complex \f[B]\(ga\f[R]evoke.yaml\f[B]\(ga\f[R] file:

\f[B]\(ga\(ga\(ga\f[R]yaml
siteName: \(dqMy Awesome Site\(dq
author: \(dqJohn Doe\(dq
baseURL: \(dqhttps://example.com\(dq
social:
  twitter: \(dq\(atjohndoe\(dq
  github: \(dqjohndoe\(dq
.EE
.SS Accessing Configuration Values in Templates
All values from your \f[CR]evoke.yaml\f[R] file are available in your
templates under the \f[CR].Global\f[R] object.
For example, to display the site name and author from the example above,
you would use the following in your HTML files:
.IP
.EX
<\f[B]h1\f[R]>{{ .Global.siteName }}</\f[B]h1\f[R]>
<\f[B]p\f[R]>By {{ .Global.author }}</\f[B]p\f[R]>
.EE
.PP
To access nested values, like the social media links, you can chain the
keys:
.IP
.EX
<\f[B]a\f[R] href=\(dqhttps://twitter.com/{{ .Global.social.twitter }}\(dq>Twitter</\f[B]a\f[R]>
<\f[B]a\f[R] href=\(dqhttps://github.com/{{ .Global.social.github }}\(dq>GitHub</\f[B]a\f[R]>
.EE
.PP
This flexibility allows you to create highly customized and dynamic
templates with ease.
# Content
.PP
Evoke supports both Markdown and HTML for creating content, giving you
the flexibility to choose the best format for your needs.
.SS Markdown (\f[CR].md\f[R])
Markdown is a lightweight markup language that is perfect for writing
content like blog posts, articles, and documentation.
Evoke uses the Goldmark library to convert your Markdown files to HTML.
.SS Example
.IP
.EX
# My First Page

This is a paragraph. I can use **bold** and *italic* text.

\- This is a list item.
\- This is another list item.
.EE
.SS HTML (\f[CR].html\f[R])
For more complex layouts or when you need precise control over the
output, you can use standard HTML files.
Any template syntax within these files will be processed by Evoke.
.SS Example
.IP
.EX
<\f[B]h1\f[R]>My First Page</\f[B]h1\f[R]>
<\f[B]p\f[R]>This is a standard HTML page.</\f[B]p\f[R]>
.EE
.SS Routing
Evoke creates routes based on the file and directory structure within
your \f[CR]content\f[R] directory.
For example, consider the following structure:
.IP
.EX
content/
├── about.md
└── blog/
    ├── post\-1.md
    └── post\-2.html
.EE
.PP
This will generate the following pages:
.IP \(bu 2
\f[CR]/about.html\f[R]
.IP \(bu 2
\f[CR]/blog/post\-1.html\f[R]
.IP \(bu 2
\f[CR]/blog/post\-2.html\f[R]
.SS Frontmatter
You can add metadata to your Markdown files using YAML frontmatter.
This is a block of YAML at the top of the file, enclosed in
triple\-dashed lines (\f[CR]\-\-\-\f[R]).
.PP
Frontmatter allows you to define variables that can be accessed in your
templates.
This is useful for setting page titles, authors, dates, and other custom
data.
.SS Example
Here\(cqs an example of a Markdown file with frontmatter:
.IP
.EX
\f[I]\-\-\-\f[R]
\f[BI]title:\f[R]\f[I] \(dqMy First Blog Post\(dq\f[R]
\f[BI]author:\f[R]\f[I] \(dqJane Doe\(dq\f[R]
\f[BI]date:\f[R]\f[I] \(dq2024\-07\-08\(dq\f[R]
\f[BI]tags:\f[R]\f[I] [\(dqtech\(dq, \(dqgolang\(dq]\f[R]
\f[I]\-\-\-\f[R]

# My First Blog Post

This is the content of my blog post.
.EE
.SS Accessing Frontmatter in Templates
You can access these variables in your templates using the
\f[CR].Page\f[R] object.
For example, to display the title and author in a layout:
.IP
.EX
<!DOCTYPE html>
<\f[B]html\f[R]>
<\f[B]head\f[R]>
  <\f[B]title\f[R]>{{ .Page.title }}</\f[B]title\f[R]>
</\f[B]head\f[R]>
<\f[B]body\f[R]>
  <\f[B]h1\f[R]>{{ .Page.title }}</\f[B]h1\f[R]>
  <\f[B]p\f[R]>By {{ .Page.author }} on {{ .Page.date }}</\f[B]p\f[R]>

  <\f[B]div\f[R]>
    {{ .Content }}
  </\f[B]div\f[R]>
</\f[B]body\f[R]>
</\f[B]html\f[R]>
.EE
.PP
In this example, \f[CR]{{ .Content }}\f[R] is a special variable that
contains the rendered HTML of the Markdown content.
.PP
Frontmatter is supported for both Markdown and HTML files.
.SS Layouts
Evoke uses a simple layout system to help you create consistent page
structures.
By default, Evoke will look for a \f[CR]_layout.html\f[R] file in the
same directory as your content file.
If it doesn\(cqt find one, it will look in the parent directory, and so
on, all the way up to the \f[CR]content\f[R] directory.
.SS Example
Consider the following directory structure:
.IP
.EX
content/
├── _layout.html
└── blog/
    ├── _layout.html
    └── post\-1.md
.EE
.PP
In this example, \f[CR]post\-1.md\f[R] will be rendered using the
\f[CR]blog/_layout.html\f[R] file.
If \f[CR]blog/_layout.html\f[R] didn\(cqt exist, it would be rendered
using \f[CR]content/_layout.html\f[R].
.PP
This allows you to create a default layout for your entire site, and
then override it for specific sections of your site.
# Development Server
.PP
Evoke comes with a powerful development server that makes it easy to
preview your site locally and see changes in real\-time.
To start the server, run the following command in your project\(cqs root
directory:
.IP
.EX
evoke serve
.EE
.PP
This will start a local server, typically at
\f[CR]http://localhost:8990\f[R], and watch your project files for
changes.
.SS Live Reloading
The development server features live reloading, which means that it will
automatically reload your browser whenever you make a change to a file.
This is a huge productivity booster, as it allows you to see the results
of your changes instantly without having to manually refresh the page.
.SS How It Works
The development server uses a WebSocket connection to communicate with
your browser.
When you start the server, it injects a small JavaScript file into each
HTML page.
This script establishes a WebSocket connection with the server and
listens for messages.
.PP
When you change a file, the server detects the change and sends a
message to the browser over the WebSocket connection.
The browser then reloads the page to reflect the changes.
.SS CSS Hot\-Reloading
For an even faster development experience, the development server
supports CSS hot\-reloading.
This means that when you change a CSS file, the new styles are injected
directly into the page without a full page reload.
This is especially useful when you\(cqre tweaking the design of your
site, as it allows you to see the results of your changes instantly.
.SS Error Overlay
If you make a mistake in your code that causes the build to fail, the
development server will display an error overlay in your browser.
This overlay shows the error message and the file that caused the error,
making it easy to identify and fix the problem.
# Directory Structure
.PP
Evoke uses a simple directory structure to organize your site.
.IP \(bu 2
\f[CR]content/\f[R]: This directory contains all of your site\(cqs
content, including Markdown and HTML files.
It can also contain a \f[CR]_layout.html\f[R] file to define the base
layout for your pages.
The directory structure within the \f[CR]content\f[R] directory will be
used to generate the URLs for your site.
For example, a file at \f[CR]content/blog/my\-post.md\f[R] will be
available at \f[CR]/blog/my\-post.html\f[R].
.IP \(bu 2
\f[CR]public/\f[R]: This directory contains all of your site\(cqs static
assets, such as images, CSS, and JavaScript files.
The contents of this directory will be copied to the \f[CR]dist\f[R]
directory when you build your site.
.IP \(bu 2
\f[CR]partials/\f[R]: This directory contains all of your site\(cqs
partials, which are reusable HTML snippets that can be included in your
content files.
For example, you could create a partial for your site\(cqs header and
another for your site\(cqs footer.
.IP \(bu 2
\f[CR]plugins/\f[R]: This directory contains all of your site\(cqs
plugins, which are Go plugins that can be used to extend Evoke\(cqs
functionality.
For example, you could create a plugin to add support for a new
templating language or to add a custom build step.
.IP \(bu 2
\f[CR]dist/\f[R]: This directory is where your static site will be
generated.
You should not edit the contents of this directory directly, as it will
be overwritten every time you build your site.
.IP \(bu 2
\f[CR]evoke.yaml\f[R]: An optional configuration file for your site.
This file can be used to configure your site\(cqs name, URL, and other
settings.
# Layouts
.PP
Evoke uses a simple yet powerful layout system to help you create
consistent page structures for your site.
Layouts are defined using \f[CR]_layout.html\f[R] files, and they allow
you to define a common structure for a set of pages.
.SS The \f[CR]_layout.html\f[R] File
A layout is an HTML file that contains the basic structure of a page.
It typically includes the \f[CR]<html>\f[R], \f[CR]<head>\f[R], and
\f[CR]<body>\f[R] tags, as well as any other common elements that you
want to appear on every page, such as a header, footer, or navigation
bar.
.PP
The key to a layout file is the \f[CR]{{ .Content }}\f[R] variable.
This is where the content of the individual pages will be injected.
.SS Example
Here\(cqs an example of a basic layout file:
.PP
\f[CR]content/_layout.html\f[R]:
.IP
.EX
<!DOCTYPE html>
<\f[B]html\f[R] lang=\(dqen\(dq>
<\f[B]head\f[R]>
  <\f[B]meta\f[R] charset=\(dqUTF\-8\(dq>
  <\f[B]title\f[R]>{{ .Page.title }}</\f[B]title\f[R]>
</\f[B]head\f[R]>
<\f[B]body\f[R]>
  <\f[B]header\f[R]>
    <\f[B]h1\f[R]>{{ .Global.siteName }}</\f[B]h1\f[R]>
  </\f[B]header\f[R]>

  <\f[B]main\f[R]>
    {{ .Content }}
  </\f[B]main\f[R]>

  <\f[B]footer\f[R]>
    <\f[B]p\f[R]>&copy; 2024 {{ .Global.siteName }}</\f[B]p\f[R]>
  </\f[B]footer\f[R]>
</\f[B]body\f[R]>
</\f[B]html\f[R]>
.EE
.PP
In this example, \f[CR]{{ .Page.title }}\f[R] will be replaced with the
title from the page\(cqs front matter, and
\f[CR]{{ .Global.siteName }}\f[R] will be replaced with the site name
from the \f[CR]evoke.yaml\f[R] file.
.SS Hierarchical Layouts
Evoke\(cqs layout system is hierarchical.
When rendering a page, Evoke will look for a \f[CR]_layout.html\f[R]
file in the same directory as the page.
If it doesn\(cqt find one, it will look in the parent directory, and so
on, all the way up to the \f[CR]content\f[R] directory.
.PP
This allows you to create a default layout for your entire site, and
then override it for specific sections.
.SS Example
Consider the following directory structure:
.IP
.EX
content/
├── _layout.html
└── blog/
    ├── _layout.html
    └── post\-1.md
.EE
.PP
In this example, \f[CR]post\-1.md\f[R] will be rendered using the
\f[CR]blog/_layout.html\f[R] file.
If \f[CR]blog/_layout.html\f[R] didn\(cqt exist, it would be rendered
using \f[CR]content/_layout.html\f[R].
.SS Nested Layouts
Layouts can also be nested.
This is useful for creating complex page structures with multiple levels
of inheritance.
.SS Example
Let\(cqs say you have a base layout for your entire site, and then a
separate layout for your blog that adds a sidebar.
.PP
\f[CR]content/_layout.html\f[R]:
.IP
.EX
<!DOCTYPE html>
<\f[B]html\f[R] lang=\(dqen\(dq>
<\f[B]head\f[R]>
  <\f[B]title\f[R]>{{ .Page.title }}</\f[B]title\f[R]>
</\f[B]head\f[R]>
<\f[B]body\f[R]>
  {{ .Content }}
</\f[B]body\f[R]>
</\f[B]html\f[R]>
.EE
.PP
\f[CR]content/blog/_layout.html\f[R]:
.IP
.EX
<\f[B]div\f[R] class=\(dqcontainer\(dq>
  <\f[B]main\f[R] class=\(dqmain\-content\(dq>
    {{ .Content }}
  </\f[B]main\f[R]>
  <\f[B]aside\f[R] class=\(dqsidebar\(dq>
    <\f[B]h2\f[R]>Recent Posts</\f[B]h2\f[R]>
    <\f[B]ul\f[R]>
      <\f[B]li\f[R]>Post 1</\f[B]li\f[R]>
      <\f[B]li\f[R]>Post 2</\f[B]li\f[R]>
    </\f[B]ul\f[R]>
  </\f[B]aside\f[R]>
</\f[B]div\f[R]>
.EE
.PP
When \f[CR]post\-1.md\f[R] is rendered, its content will first be
injected into \f[CR]content/blog/_layout.html\f[R] in place of
\f[CR]{{ .Content }}\f[R].
Then, the \f[I]entire result\f[R] of that will be injected into
\f[CR]content/_layout.html\f[R] in place of its
\f[CR]{{ .Content }}\f[R].
# Partials
.PP
Partials are reusable HTML snippets that help you keep your code DRY
(Don\(cqt Repeat Yourself).
They are stored in the \f[CR]partials\f[R] directory and can be included
in your layouts and content files.
.SS Creating a Partial
To create a partial, simply create an HTML file in the
\f[CR]partials\f[R] directory.
.SS Example: \f[CR]partials/header.html\f[R]
.IP
.EX
<\f[B]header\f[R]>
  <\f[B]h1\f[R]>{{ .Global.siteName }}</\f[B]h1\f[R]>
  <\f[B]p\f[R]>Welcome to my awesome site!</\f[B]p\f[R]>
</\f[B]header\f[R]>
.EE
.SS Using a Partial
To include a partial, use the \f[CR]template\f[R] keyword.
The \f[CR].\f[R] (dot) passes the current context (e.g., page variables,
site configuration) to the partial.
.SS Example: \f[CR]content/_layout.html\f[R]
.IP
.EX
<!DOCTYPE html>
<\f[B]html\f[R] lang=\(dqen\(dq>
<\f[B]head\f[R]>
  <\f[B]meta\f[R] charset=\(dqUTF\-8\(dq />
  <\f[B]title\f[R]>{{ .Page.title }}</\f[B]title\f[R]>
</\f[B]head\f[R]>
<\f[B]body\f[R]>
  {{ template \(dqheader.html\(dq . }}

  <\f[B]main\f[R]>
    {{ .Content }}
  </\f[B]main\f[R]>

  {{ template \(dqfooter.html\(dq . }}
</\f[B]body\f[R]>
</\f[B]html\f[R]>
.EE
.SS Passing Custom Data to Partials
You can also pass custom data to a partial.
This is useful for creating reusable components that can be customized
on a per\-page basis.
.SS Example: A \f[CR]card\f[R] Partial
Let\(cqs create a partial to display a card with a title and content.
.PP
\f[CR]partials/card.html\f[R]:
.IP
.EX
<\f[B]div\f[R] class=\(dqcard\(dq>
  <\f[B]h2\f[R]>{{ .Title }}</\f[B]h2\f[R]>
  <\f[B]p\f[R]>{{ .Content }}</\f[B]p\f[R]>
</\f[B]div\f[R]>
.EE
.PP
Now, you can use this partial in your content files and pass data to it
using the \f[CR]dict\f[R] function:
.PP
\f[CR]content/index.md\f[R]:
.IP
.EX
\-\-\-
title: \(dqHome Page\(dq
\-\-\-

# Welcome to the Home Page

Here are some featured items:

{{ template \(dqcard.html\(dq (dict \(dqTitle\(dq \(dqCard 1\(dq \(dqContent\(dq \(dqThis is the first card.\(dq) }}
{{ template \(dqcard.html\(dq (dict \(dqTitle\(dq \(dqCard 2\(dq \(dqContent\(dq \(dqThis is the second card.\(dq) }}
.EE
.SS Looping with Partials
Partials are also great for rendering lists of items.
For example, you could loop through a list of blog posts and render a
partial for each one.
.SS Example: Listing Blog Posts
Imagine you have a list of posts in your \f[CR]evoke.yaml\f[R]:
.IP
.EX
posts\f[B]:\f[R]
  \f[B]\-\f[R] title\f[B]:\f[R] \(dqPost 1\(dq
    url\f[B]:\f[R] \(dq/blog/post\-1\(dq
  \f[B]\-\f[R] title\f[B]:\f[R] \(dqPost 2\(dq
    url\f[B]:\f[R] \(dq/blog/post\-2\(dq
.EE
.PP
You can then loop through these posts in your template and render a
partial for each one:
.PP
\f[CR]content/blog.html\f[R]:
.IP
.EX
<\f[B]h1\f[R]>Blog</\f[B]h1\f[R]>
<\f[B]ul\f[R]>
  {{ range .Global.posts }}
    {{ template \(dqpost\-summary.html\(dq . }}
  {{ end }}
</\f[B]ul\f[R]>
.EE
.PP
\f[CR]partials/post\-summary.html\f[R]:
.IP
.EX
<\f[B]li\f[R]>
  <\f[B]a\f[R] href=\(dq{{ .url }}\(dq>{{ .title }}</\f[B]a\f[R]>
</\f[B]li\f[R]>
.EE
.PP
This powerful combination of partials, data, and loops allows you to
build complex and maintainable websites with ease.
.SS Nested Partials
You can also nest partials within other partials.
This is useful for creating complex components from smaller, more
manageable pieces.
.SS Example: A \f[CR]profile\f[R] Partial
Let\(cqs create a \f[CR]profile\f[R] partial that uses a \f[CR]card\f[R]
partial.
.PP
\f[CR]partials/profile.html\f[R]:
.IP
.EX
<\f[B]div\f[R] class=\(dqprofile\(dq>
  {{ template \(dqcard.html\(dq (dict \(dqTitle\(dq .Page.Name \(dqContent\(dq .Page.Bio) }}
</\f[B]div\f[R]>
.EE
.PP
Now, you can use the \f[CR]profile\f[R] partial in your content files:
.PP
\f[CR]content/about.md\f[R]:
.IP
.EX
\f[I]\-\-\-\f[R]
\f[BI]title:\f[R]\f[I] \(dqAbout Me\(dq\f[R]
\f[BI]Name:\f[R]\f[I] \(dqJohn Doe\(dq\f[R]
\f[BI]Bio:\f[R]\f[I] \(dqI am a web developer.\(dq\f[R]
\f[I]\-\-\-\f[R]

# About Me

{{ template \(dqprofile.html\(dq . }}
# Performance

Evoke is engineered from the ground up for speed and efficiency, ensuring that your site builds quickly without monopolizing system resources. This is accomplished through a combination of a lightweight architecture, efficient algorithms, and the inherent performance of the Go programming language.

## The Go Advantage

Evoke is written in Go, a language celebrated for its performance and concurrency. This choice provides several key advantages:

\-   **Single Binary Deployment:** Evoke compiles to a single, self\-contained binary. This means there are no external dependencies to install or manage, making it incredibly fast to deploy and execute.
\-   **Built\-in Concurrency:** Go\(aqs goroutines and channels provide a powerful and efficient model for concurrency. Evoke leverages this to parallelize tasks and maximize the use of available CPU cores.

## Core Performance Features

### High\-Throughput Build Process

Evoke\(aqs build process is designed for maximum throughput. Here are some of the key features that make it so fast:

\-   **Parallel File Processing:** Evoke processes your content files in parallel, taking full advantage of multi\-core processors to dramatically reduce build times. It creates a pool of workers, with one worker per CPU core, to ensure that your site is built as quickly as possible.
\-   **In\-Memory Caching:** Layouts and templates are parsed once and then cached in memory. This avoids redundant file I/O and parsing operations, resulting in a significant speed boost. The cache is implemented using a \f[BI]\(gasync.Map\(ga\f[R], which is optimized for concurrent access.
\-   **Efficient Memory Management:** Evoke is designed to be light on memory usage. We use a \f[BI]\(gasync.Pool\(ga\f[R] to reuse memory buffers for file I/O and content processing. This reduces the number of memory allocations and the pressure on the garbage collector, leading to faster and more consistent build times.
\-   **Singleton Parsers:** The Goldmark Markdown parser is initialized only once and then reused for all Markdown files. This avoids the significant overhead of creating a new parser for each file.

### The Plugin System and Performance

Evoke\(aqs plugin system is designed to be flexible and powerful, but it\(aqs important to be aware of the performance implications of the plugins you use. While the core of Evoke is highly optimized, a poorly written plugin can slow down your build.

Here are some things to keep in mind when writing or using plugins:

\-   **Plugin Hooks:** Plugins can \(dqhook\(dq into various stages of the build process. Be mindful of the hooks you use and the work you do in them. For example, a heavy computation in a hook that runs for every file can have a significant impact on build times.
\-   **Memory Allocations:** Be mindful of memory allocations in your plugins. If you need to work with large amounts of data, consider using a \f[BI]\(gasync.Pool\(ga\f[R] to reuse buffers, just like Evoke does internally.
\-   **Caching:** If your plugin performs expensive operations, consider implementing your own caching layer to avoid redundant work.

## Benchmark Results

To provide a transparent look at our performance, we\(aqve included the results from our benchmark tests. These tests were run on an Apple M1 CPU and measure the performance of key components in the Evoke ecosystem.

The following metrics are used:

\-   \f[BI]\(gans/op\(ga\f[R]: The average time each operation takes in nanoseconds. Lower is better.
\-   \f[BI]\(gaB/op\(ga\f[R]: The average number of bytes allocated per operation. Lower is better.
\-   \f[BI]\(gaallocs/op\(ga\f[R]: The average number of memory allocations per operation. Lower is better.

### Build (\(gapkg/build\(ga)

This benchmark measures the time it takes to build a site with 100 pages from scratch. This includes loading plugins, copying public assets, processing content, and running all associated hooks. It provides a holistic view of the site generation time.

> **Note:** The clean build is now slower than it was previously. This is because Evoke now builds a dependency graph and hashes all of your files to enable incremental builds. While the initial build is slower, subsequent builds will be significantly faster.

| Benchmark      | Time/op (ms) | Memory/op (MB) | Allocations/op |
| \-\-\-\-\-\-\-\-\-\-\-\-\-\- | \-\-\-\-\-\-\-\-\-\-\-\- | \-\-\-\-\-\-\-\-\-\-\-\-\-\- | \-\-\-\-\-\-\-\-\-\-\-\-\-\- |
| BenchmarkBuild | 46.15        | 7.62           | 31283          |

### Pipelines (\(gapkg/pipelines\(ga)

These benchmarks measure the time it takes for each content pipeline to process a realistic piece of content.

| Benchmark                 | Time/op (ms) | Memory/op (KB) | Allocations/op | Notes                               |
| \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\- | \-\-\-\-\-\-\-\-\-\-\-\- | \-\-\-\-\-\-\-\-\-\-\-\-\-\- | \-\-\-\-\-\-\-\-\-\-\-\-\-\- | \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\- |
| BenchmarkMarkdownPipeline | 0.15         | 111.13         | 429            | Processes a 100\-paragraph MD file   |
| BenchmarkHTMLPipeline     | 0.01         | 32.34          | 8              | Processes a 100\-paragraph HTML file |
| BenchmarkCopyPipeline     | 0.12         | 1048.63        | 2              | Processes a 1MB file                |

### Partials (\(gapkg/partials\(ga)

This benchmark measures the time it takes to load and parse 50 partial templates from the \f[BI]\(gapartials\(ga\f[R] directory.

| Benchmark             | Time/op (ms) | Memory/op (KB) | Allocations/op |
| \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\- | \-\-\-\-\-\-\-\-\-\-\-\- | \-\-\-\-\-\-\-\-\-\-\-\-\-\- | \-\-\-\-\-\-\-\-\-\-\-\-\-\- |
| BenchmarkLoadPartials | 2.24         | 246.05         | 2148           |

### Plugins (\(gapkg/plugins\(ga)

This benchmark measures the overhead of the plugin system by sending a 10KB payload over gRPC.

| Benchmark       | Time/op (ms) | Memory/op (KB) | Allocations/op |
| \-\-\-\-\-\-\-\-\-\-\-\-\-\-\- | \-\-\-\-\-\-\-\-\-\-\-\- | \-\-\-\-\-\-\-\-\-\-\-\-\-\- | \-\-\-\-\-\-\-\-\-\-\-\-\-\- |
| BenchmarkPlugin | 0.10         | 76.10          | 187            |

### Util (\(gapkg/util\(ga)

These benchmarks measure the performance of common file system operations.

| Benchmark              | Time/op (ms) | Memory/op (MB) | Allocations/op | Notes                           |
| \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\- | \-\-\-\-\-\-\-\-\-\-\-\- | \-\-\-\-\-\-\-\-\-\-\-\-\-\- | \-\-\-\-\-\-\-\-\-\-\-\-\-\- | \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\- |
| BenchmarkCopyFile      | 0.96         | 0.03           | 10             | Copies a 1MB file               |
| BenchmarkCopyDirectory | 14.06        | 2.43           | 1603           | Copies a directory with 100+ files |

## Comparative Analysis

To provide a clear picture of how Evoke stacks up against other popular static site generators, we conducted a comparative analysis with Hugo, Eleventy, and Gatsby. The following benchmarks were run on a test site with 5,000 markdown files.

The test was conducted on an Apple M1 CPU. Each project was set up with a basic configuration, and the build time was measured using the \f[BI]\(gatime\(ga\f[R] command.

| SSG      | Build Time (real) | Time Difference | Times Slower |
| \-\-\-\-\-\-\-\- | \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\- | \-\-\-\-\-\-\-\-\-\-\-\-\-\-\- | \-\-\-\-\-\-\-\-\-\-\-\- |
| Evoke    | 1.50s             | \-               | \-            |
| Hugo     | 4.453s            | +2.953s         | 2.97x        |
| Eleventy | 4.650s            | +3.15s          | 3.10x        |
| Gatsby   | 22.432s           | +20.932s        | 14.95x       |

As the results show, Evoke is significantly faster than the other static site generators in this test case. This is a testament to Evoke\(aqs lightweight architecture and efficient design. While this benchmark is not exhaustive, it provides a strong indication of Evoke\(aqs performance advantages for content\-heavy sites.

## Summary

Evoke\(aqs commitment to performance means you can iterate on your site more quickly and spend less time waiting for builds. We are continuously working to make Evoke even faster and more efficient, and we encourage our community to adopt performance\-conscious practices when developing plugins.
# Getting Started with Evoke

Welcome to Evoke! This guide will walk you through installing Evoke and creating your first website.

## Installation

You can install Evoke in one of the following ways:

**1. Installer Script (Recommended):**

You can use the following command to download and install the latest version of Evoke for your system:

\f[BI]\(ga\(ga\(gabash\f[R]
curl \-sSL https://raw.githubusercontent.com/Bitlatte/evoke/main/install.sh \f[B]|\f[R] sh
.EE
.PP
\f[B]2.
From a Release:\f[R]
.PP
Download the pre\-compiled binary for your operating system from the \c
.UR https://github.com/Bitlatte/evoke/releases/latest
latest release
.UE \c
\ on GitHub.
Unzip the archive and place the \f[CR]evoke\f[R] binary in a directory
that is in your system\(cqs \f[CR]PATH\f[R].
.PP
\f[B]3.
From Source:\f[R]
.PP
If you have Go installed, you can also install Evoke from source using
the \f[CR]go install\f[R] command:
.IP
.EX
go install github.com/Bitlatte/evoke/cmd/evoke\(atlatest
.EE
.SS Your First Project
The easiest way to start a new Evoke project is to use the
\f[CR]init\f[R] command.
.IP "1." 3
\f[B]Initialize the Project:\f[R]
.RS 4
.PP
Run the \f[CR]evoke init\f[R] command.
This will create a basic project structure for you.
.IP
.EX
evoke init
.EE
.RE
.IP "2." 3
\f[B]Create Your First Page:\f[R]
.RS 4
.PP
You can now create a file named \f[CR]index.md\f[R] inside the
\f[CR]content\f[R] directory:
.IP
.EX
# Welcome to My Awesome Site!

This is my first page. I can use **Markdown** to format my text.
.EE
.RE
.IP "3." 3
\f[B]Build Your Site:\f[R]
.RS 4
.PP
Run the \f[CR]evoke build\f[R] command from your project\(cqs root
directory:
.IP
.EX
evoke build
.EE
.PP
Evoke will generate your static site in a new \f[CR]dist\f[R] directory.
Open \f[CR]dist/index.html\f[R] in your browser to see the result.
.RE
.SS Live Reloading
Evoke comes with a built\-in development server that will automatically
reload your site when you make changes.
To start the development server, run the \f[CR]evoke serve\f[R] command
from the root of your project.
.IP
.EX
evoke serve
.EE
.PP
This will start a local web server at \f[CR]http://localhost:8990\f[R].
Open this URL in your browser to see your site.
Now, whenever you make a change to a file in your project, Evoke will
automatically rebuild your site and reload the page in your browser.
.SS Project Structure Explained
As your project grows, you can add more directories to organize your
files:
.IP
.EX
\&.
├── content/      # Your site\(aqs pages (Markdown or HTML)
├── partials/     # Reusable HTML snippets
├── public/       # Static assets (CSS, images, etc.)
├── plugins/      # Custom Evoke plugins
└── evoke.yaml    # Optional configuration file
.EE
.IP \(bu 2
\f[B]\f[CB]content/\f[B]\f[R]: This is where all your website\(cqs pages
live.
Evoke processes these files and converts them to HTML.
.IP \(bu 2
\f[B]\f[CB]partials/\f[B]\f[R]: This directory holds reusable HTML
snippets that you can include in your pages, like headers or footers.
.IP \(bu 2
\f[B]\f[CB]public/\f[B]\f[R]: Any files in this directory (e.g., CSS,
JavaScript, images) are copied directly to the \f[CR]dist\f[R] folder
without changes.
.IP \(bu 2
\f[B]\f[CB]plugins/\f[B]\f[R]: You can add custom Go code here to extend
Evoke\(cqs functionality.
.IP \(bu 2
\f[B]\f[CB]evoke.yaml\f[B]\f[R]: This optional file allows you to
customize your site\(cqs settings.
.SS What\(cqs Next?
You\(cqve successfully built your first site with Evoke!
To learn more about what you can do, check out the \f[B]Core
Concepts\f[R].
# Evoke: Simply magical.
.PP
Welcome to the official documentation for Evoke.
Evoke is a static site generator that operates on the principle of
\(lqIt just works.\(rq It\(cqs not about complex commands or convoluted
processes, but about the purity and speed of a tool so refined it feels
like a natural extension of the developer\(cqs will.
.SS Why Evoke?
There are a lot of static site generators out there, so why build
another one?
The answer is simple: I wanted a static site generator that was small,
fast, and powerful, but also easy to use.
I wanted a tool that would let me build a website without having to
worry about a lot of configuration or setup.
I also wanted a tool that was extensible, so I could add new features
and functionality as needed.
.PP
Evoke is the result of that vision.
It\(cqs a tool that I use every day to build my own websites, and I hope
that you\(cqll find it as useful as I do.
.SS Core Concepts
Evoke is built around a few core concepts that make it powerful and easy
to use.
Understanding these concepts will help you get the most out of Evoke.
.IP \(bu 2
\f[B]Build Process:\f[R] Learn how Evoke takes your content and turns it
into a static website.
.IP \(bu 2
\f[B]Configuration:\f[R] Discover how to customize your project with the
\f[CR]evoke.yaml\f[R] file.
.IP \(bu 2
\f[B]Content:\f[R] Find out how to create and organize your content
using HTML and Markdown.
.IP \(bu 2
\f[B]Directory Structure:\f[R] Understand the purpose of each directory
in an Evoke project.
.IP \(bu 2
\f[B]Partials:\f[R] Learn how to create reusable snippets of HTML.
.IP \(bu 2
\f[B]Performance:\f[R] See what makes Evoke so fast and efficient.
.SS Getting Started
If you\(cqre ready to learn more, head over to the Getting Started page
for a more in\-depth guide to creating your first project.
.SS Plugins
Evoke has a powerful plugin system that allows you to extend the core
functionality of the static site generator.
You can use plugins to add new features, such as support for additional
languages, new template functions, or custom build steps.
.IP \(bu 2
\f[B]Creating Plugins:\f[R] Learn how to create your own plugins to
extend the functionality of Evoke.
.IP \(bu 2
\f[B]Installing Plugins:\f[R] Find out how to install and use plugins in
your Evoke project.
.SS Contributing
Evoke is an open\-source project, and we welcome contributions from the
community.
Whether you\(cqre a developer, a designer, or a writer, there are many
ways to contribute to the project.
.IP \(bu 2
\f[B]Reporting Bugs:\f[R] If you find a bug, please report it so we can
fix it.
.IP \(bu 2
\f[B]Suggesting Features:\f[R] Have an idea for a new feature?
We\(cqd love to hear it.
.IP \(bu 2
\f[B]Contributing Code:\f[R] If you\(cqre a developer, you can
contribute to the project by writing code.
.SS Need Help?
If you have any questions or need help with Evoke, please feel free to
reach out to us.
.IP \(bu 2
\f[B]\c
.UR https://github.com/Bitlatte/evoke/issues
GitHub Issues
.UE \c
:\f[R] Report bugs and suggest features.
# Building and Installing Plugins
.PP
This guide explains how to build your plugins into executables that
Evoke can use and how to install them in your project.
.SS Building Your Plugin
Evoke plugins are compiled as standalone executables.
To build your plugin, navigate to your project\(cqs root directory and
use the \f[CR]go build\f[R] command.
.SS Example
Let\(cqs say you have a plugin located in
\f[CR]plugins/my\-plugin/main.go\f[R].
You would build it with the following command:
.IP
.EX
go build \-o plugins/my\-plugin/my\-plugin plugins/my\-plugin/main.go
.EE
.PP
This command does the following:
.IP \(bu 2
\f[CR]go build\f[R]: The standard Go command to compile packages and
dependencies.
.IP \(bu 2
\f[CR]\-o plugins/my\-plugin/my\-plugin\f[R]: This specifies the output
file name and location.
By convention, place the compiled plugin directly in the plugin\(cqs
directory.
.IP \(bu 2
\f[CR]plugins/my\-plugin/main.go\f[R]: This is the path to your
plugin\(cqs source code.
.SS Installing Your Plugin
Once you have built your plugin, it is already \(lqinstalled\(rq and
ready to be used by Evoke.
Evoke automatically discovers and loads any executable files found in
the \f[CR]plugins\f[R] directory.
.PP
There are no further steps required.
The next time you run an \f[CR]evoke\f[R] command, your plugin\(cqs
hooks will be active.
.SS Cross\-Compilation
If you are developing a plugin that you want to distribute to others,
you will need to compile it for different operating systems and
architectures.
You can do this by setting the \f[CR]GOOS\f[R] and \f[CR]GOARCH\f[R]
environment variables before running the \f[CR]go build\f[R] command.
.PP
For example, to build your plugin for Windows, you would run the
following command:
.IP
.EX
GOOS=windows GOARCH=amd64 go build \-o plugins/my\-plugin/my\-plugin.exe plugins/my\-plugin/main.go
.EE
.PP
To build your plugin for Linux, you would run the following command:
.IP
.EX
GOOS=linux GOARCH=amd64 go build \-o plugins/my\-plugin/my\-plugin plugins/my\-plugin/main.go
.EE
.SS Distributing Your Plugin
Once you have built your plugin for different operating systems and
architectures, you can distribute it to others.
The easiest way to do this is to create a zip file containing the
compiled plugin and any other assets that it needs.
.PP
You can then share this zip file with others, and they can install it by
unzipping it into their project\(cqs \f[CR]plugins\f[R] directory.
# Creating Plugins
.PP
This guide will walk you through the process of creating your first
Evoke plugin.
We\(cqll create a simple plugin that prints a message during the build
process.
.SS Prerequisites
Before you begin, make sure you have the following installed:
.IP \(bu 2
Go
.IP \(bu 2
Protobuf Compiler (\f[CR]protoc\f[R])
.IP \(bu 2
Go gRPC plugins
.PP
You can install the Protobuf Compiler and the Go gRPC plugins with the
following commands:
.IP
.EX
brew install protobuf
go install google.golang.org/protobuf/cmd/protoc\-gen\-go\(atv1.28
go install google.golang.org/grpc/cmd/protoc\-gen\-go\-grpc\(atv1.2
.EE
.SS Step 1: Create a New Directory
First, create a new directory for your plugin inside your project\(cqs
\f[CR]plugins\f[R] directory.
For this example, we\(cqll create a \f[CR]hello\f[R] plugin.
.IP
.EX
mkdir \-p plugins/hello
.EE
.SS Step 2: Create the Plugin File
Inside the \f[CR]plugins/hello\f[R] directory, create a new file named
\f[CR]main.go\f[R].
This file will contain the code for your plugin.
.IP
.EX
\f[B]package\f[R] main

\f[B]import\f[R] (
    \(dqcontext\(dq
    \(dqfmt\(dq

    \(dqgithub.com/Bitlatte/evoke/pkg/plugins\(dq
    \(dqgithub.com/Bitlatte/evoke/proto\(dq
    \(dqgithub.com/hashicorp/go\-plugin\(dq
)

\f[I]// Here is a real implementation of the plugin.\f[R]
\f[B]type\f[R] HelloPlugin \f[B]struct\f[R]{}

\f[B]func\f[R] (p *HelloPlugin) OnPreBuild(ctx context.Context, req *proto.OnPreBuildRequest) (*proto.OnPreBuildResponse, error) {
    fmt.Println(\(dqHello from the OnPreBuild hook!\(dq)
    \f[B]return\f[R] &proto.OnPreBuildResponse{}, nil
}

\f[B]func\f[R] (p *HelloPlugin) OnConfigLoaded(ctx context.Context, req *proto.OnConfigLoadedRequest) (*proto.OnConfigLoadedResponse, error) {
    fmt.Println(\(dqHello from the OnConfigLoaded hook!\(dq)
    \f[B]return\f[R] &proto.OnConfigLoadedResponse{Config: req.Config}, nil
}

\f[B]func\f[R] (p *HelloPlugin) OnPublicAssetsCopied(ctx context.Context, req *proto.OnPublicAssetsCopiedRequest) (*proto.OnPublicAssetsCopiedResponse, error) {
    fmt.Println(\(dqHello from the OnPublicAssetsCopied hook!\(dq)
    \f[B]return\f[R] &proto.OnPublicAssetsCopiedResponse{}, nil
}

\f[B]func\f[R] (p *HelloPlugin) OnContentLoaded(ctx context.Context, req *proto.OnContentLoadedRequest) (*proto.OnContentLoadedResponse, error) {
    fmt.Printf(\(dqHello from the OnContentLoaded hook for %s!\(rsn\(dq, req.Path)
    \f[B]return\f[R] &proto.OnContentLoadedResponse{Content: req.Content}, nil
}

\f[B]func\f[R] (p *HelloPlugin) OnContentRender(ctx context.Context, req *proto.OnContentRenderRequest) (*proto.OnContentRenderResponse, error) {
    fmt.Printf(\(dqHello from the OnContentRender hook for %s!\(rsn\(dq, req.Path)
    \f[B]return\f[R] &proto.OnContentRenderResponse{Content: req.Content}, nil
}

\f[B]func\f[R] (p *HelloPlugin) OnHTMLRendered(ctx context.Context, req *proto.OnHTMLRenderedRequest) (*proto.OnHTMLRenderedResponse, error) {
    fmt.Printf(\(dqHello from the OnHTMLRendered hook for %s!\(rsn\(dq, req.Path)
    \f[B]return\f[R] &proto.OnHTMLRenderedResponse{Content: req.Content}, nil
}

\f[B]func\f[R] (p *HelloPlugin) OnPostBuild(ctx context.Context, req *proto.OnPostBuildRequest) (*proto.OnPostBuildResponse, error) {
    fmt.Println(\(dqHello from the OnPostBuild hook!\(dq)
    \f[B]return\f[R] &proto.OnPostBuildResponse{}, nil
}

\f[B]func\f[R] main() {
    plugin.Serve(&plugin.ServeConfig{
        HandshakeConfig: plugins.Handshake,
        Plugins: \f[B]map\f[R][string]plugin.Plugin{
            \(dqevoke\(dq: &plugins.EvokePlugin{Impl: &HelloPlugin{}},
        },
        GRPCServer: plugin.DefaultGRPCServer,
    })
}
.EE
.SS Step 3: Build the Plugin
To build the plugin, run the following command from your project\(cqs
root directory:
.IP
.EX
go build \-o plugins/hello/hello plugins/hello/main.go
.EE
.PP
This will create a new executable file named \f[CR]hello\f[R] in your
\f[CR]plugins/hello\f[R] directory.
This is the compiled plugin that Evoke will load.
.SS Step 4: Run a Build
Now that your plugin is built, run the \f[CR]evoke build\f[R] command:
.IP
.EX
evoke build
.EE
.PP
You should see the messages from your plugin printed to the console
during the build process.
# Example Plugin: Modify Content
.PP
In this example, we\(cqll create a plugin that modifies the content of a
page before it\(cqs rendered.
This plugin will find all instances of the word \(lqHello\(rq and
replace them with \(lqHello from our plugin!\(rq.
.SS 1. Create the Plugin Directory
First, create a directory for the plugin:
.IP
.EX
mkdir \-p plugins/modifier
.EE
.SS 2. Create the \f[CR]main.go\f[R] File
Next, create a \f[CR]main.go\f[R] file inside
\f[CR]plugins/modifier\f[R]:
.IP
.EX
\f[B]package\f[R] main

\f[B]import\f[R] (
    \(dqbytes\(dq
    \(dqcontext\(dq

    \(dqgithub.com/Bitlatte/evoke/pkg/plugins\(dq
    \(dqgithub.com/Bitlatte/evoke/proto\(dq
    \(dqgithub.com/hashicorp/go\-plugin\(dq
)

\f[I]// Here is a real implementation of the plugin.\f[R]
\f[B]type\f[R] ModifierPlugin \f[B]struct\f[R]{}

\f[B]func\f[R] (p *ModifierPlugin) OnPreBuild(ctx context.Context, req *proto.OnPreBuildRequest) (*proto.OnPreBuildResponse, error) {
    \f[B]return\f[R] &proto.OnPreBuildResponse{}, nil
}

\f[B]func\f[R] (p *ModifierPlugin) OnConfigLoaded(ctx context.Context, req *proto.OnConfigLoadedRequest) (*proto.OnConfigLoadedResponse, error) {
    \f[B]return\f[R] &proto.OnConfigLoadedResponse{Config: req.Config}, nil
}

\f[B]func\f[R] (p *ModifierPlugin) OnPublicAssetsCopied(ctx context.Context, req *proto.OnPublicAssetsCopiedRequest) (*proto.OnPublicAssetsCopiedResponse, error) {
    \f[B]return\f[R] &proto.OnPublicAssetsCopiedResponse{}, nil
}

\f[B]func\f[R] (p *ModifierPlugin) OnContentLoaded(ctx context.Context, req *proto.OnContentLoadedRequest) (*proto.OnContentLoadedResponse, error) {
    newContent := bytes.ReplaceAll(req.Content, []byte(\(dqHello\(dq), []byte(\(dqHello from our plugin!\(dq))
    \f[B]return\f[R] &proto.OnContentLoadedResponse{Content: newContent}, nil
}

\f[B]func\f[R] (p *ModifierPlugin) OnContentRender(ctx context.Context, req *proto.OnContentRenderRequest) (*proto.OnContentRenderResponse, error) {
    \f[B]return\f[R] &proto.OnContentRenderResponse{Content: req.Content}, nil
}

\f[B]func\f[R] (p *ModifierPlugin) OnHTMLRendered(ctx context.Context, req *proto.OnHTMLRenderedRequest) (*proto.OnHTMLRenderedResponse, error) {
    \f[B]return\f[R] &proto.OnHTMLRenderedResponse{Content: req.Content}, nil
}

\f[B]func\f[R] (p *ModifierPlugin) OnPostBuild(ctx context.Context, req *proto.OnPostBuildRequest) (*proto.OnPostBuildResponse, error) {
    \f[B]return\f[R] &proto.OnPostBuildResponse{}, nil
}

\f[B]func\f[R] main() {
    plugin.Serve(&plugin.ServeConfig{
        HandshakeConfig: plugins.Handshake,
        Plugins: \f[B]map\f[R][string]plugin.Plugin{
            \(dqevoke\(dq: &plugins.EvokePlugin{Impl: &ModifierPlugin{}},
        },
        GRPCServer: plugin.DefaultGRPCServer,
    })
}
.EE
.PP
This code defines a new plugin that implements the
\f[CR]OnContentLoaded\f[R] hook.
This hook will be called for each content file after it\(cqs read from
disk, and it will replace all instances of \(lqHello\(rq with \(lqHello
from our plugin!\(rq.
.SS 3. Build the Plugin
Now, build the plugin as a Go executable:
.IP
.EX
go build \-o plugins/modifier/modifier plugins/modifier/main.go
.EE
.PP
This will create the \f[CR]modifier\f[R] executable file in your
\f[CR]plugins/modifier\f[R] directory.
.SS 4. Use the New Plugin
First, create a content file with the word \(lqHello\(rq in it.
For example, create \f[CR]content/index.html\f[R] with the following
content:
.IP
.EX
<\f[B]h1\f[R]>Hello, World!</\f[B]h1\f[R]>
.EE
.PP
Then, run a build:
.IP
.EX
evoke build
.EE
.PP
Now, if you open the \f[CR]dist/index.html\f[R] file, you should see
that the content has been modified:
\(ga\(ga\(gahtml
Hello from our plugin!, World!
.SH Introduction to Plugins
Evoke\(cqs plugin system is a powerful feature that allows you to add
new functionality and customize the build process.
Plugins are built on a gRPC\-based architecture, which means you can
write them in any language that supports gRPC, including Go, Python,
JavaScript, and more.
.SS What Can Plugins Do?
With plugins, you can:
.IP \(bu 2
\f[B]Modify the build process:\f[R] Hook into the build process to
perform a wide range of actions, such as fetching data from an API,
processing images, or generating a sitemap.
.IP \(bu 2
\f[B]Customize content rendering:\f[R] Intercept and modify content at
various stages of the rendering pipeline.
For example, you could add a custom Markdown renderer, or post\-process
the HTML before it\(cqs written to disk.
.IP \(bu 2
\f[B]Integrate with other tools:\f[R] Connect Evoke to other services
and tools, such as content management systems, analytics platforms, or
deployment pipelines.
.SS How Do Plugins Work?
Evoke plugins are standalone executables that communicate with the Evoke
application over gRPC.
When you run a build, Evoke discovers and launches any plugins in your
\f[CR]plugins\f[R] directory, and then communicates with them at various
points in the build process.
.SS Plugin Hooks
Plugins can execute code at specific points in the build process using
the following hooks:
.IP \(bu 2
\f[CR]OnPreBuild()\f[R]: This method is called before the build process
begins.
.IP \(bu 2
\f[CR]OnConfigLoaded()\f[R]: This method is called after the
configuration is loaded, but before it is used.
.IP \(bu 2
\f[CR]OnPublicAssetsCopied()\f[R]: This method is called after the
public assets have been copied to the output directory.
.IP \(bu 2
\f[CR]OnPostBuild()\f[R]: This method is called after the build process
has completed.
.SS The Plugin Interface
All plugins must implement the \f[CR]Plugin\f[R] service, which is
defined in the \f[CR]plugin.proto\f[R] file.
You can find the full definition of the service and its messages in the
Plugin Service Definition documentation.
.SS Getting Started with Plugins
To learn how to create your own plugins, check out the following guides:
.IP \(bu 2
\f[B]Creating Plugins:\f[R] A step\-by\-step guide to creating your
first plugin.
.IP \(bu 2
\f[B]Example Plugin:\f[R] A practical example of a plugin that adds a
new CLI command.
.IP \(bu 2
\f[B]Building and Installing:\f[R] Learn how to build and install
plugins for your projects.
# Plugin Service Definition
.PP
This document provides the full definition of the \f[CR]Plugin\f[R] gRPC
service, which is used to create plugins for Evoke.
.SS Service Definition
\(ga\(ga\(gaprotobuf syntax = \(lqproto3\(rq;
.PP
package proto;
.PP
option go_package = \(lqgithub.com/Bitlatte/evoke/proto\(rq;
.PP
// The main service that plugins must implement.
service Plugin { // \(em General Build Hooks \(em
.PP
// Called once before the entire build process begins.
// Useful for setup tasks or pre\-build validation.
rpc OnPreBuild(OnPreBuildRequest) returns (OnPreBuildResponse);
.PP
// Called after the configuration file (evoke.yaml) is loaded.
// Allows plugins to read or even modify the configuration.
rpc OnConfigLoaded(OnConfigLoadedRequest) returns
(OnConfigLoadedResponse);
.PP
// Called after the `public' directory has been copied to `dist'.
rpc OnPublicAssetsCopied(OnPublicAssetsCopiedRequest) returns
(OnPublicAssetsCopiedResponse);
.PP
// \(em Content Processing Hooks \(em
.PP
// Called for each content file after it\(cqs read from disk but before
any processing.
// Allows modification of the raw file content.
rpc OnContentLoaded(OnContentLoadedRequest) returns
(OnContentLoadedResponse);
.PP
// Called before the Markdown (or other format) content is rendered to
HTML.
// A plugin could use this to implement a custom renderer.
rpc OnContentRender(OnContentRenderRequest) returns
(OnContentRenderResponse);
.PP
// Called after content is rendered to HTML but before it\(cqs placed in
a layout.
// Useful for post\-processing the core HTML content.
rpc OnHTMLRendered(OnHTMLRenderedRequest) returns
(OnHTMLRenderedResponse);
.PP
// \(em Finalization Hooks \(em
.PP
// Called once after all content has been processed and written to disk.
rpc OnPostBuild(OnPostBuildRequest) returns (OnPostBuildResponse); }
.PP
// Represents a file being processed.
This message will be reused for // multiple hooks to pass content back
and forth.
message ContentFile { // The relative path of the file from the content
directory.
string path = 1; // The raw or processed content of the file.
bytes content = 2; }
.PP
// Represents an asset being processed by a custom pipeline.
message Asset { string path = 1; bytes content = 2; string pipeline_name
= 3; }
.PP
// Represents a custom pipeline that can be registered by a plugin.
message Pipeline { string name = 1; repeated string extensions = 2; }
.PP
message OnPreBuildRequest {} message OnPreBuildResponse {}
.PP
message OnConfigLoadedRequest { bytes config = 1; } message
OnConfigLoadedResponse { bytes config = 1; }
.PP
message OnPublicAssetsCopiedRequest {} message
OnPublicAssetsCopiedResponse {}
.PP
message OnContentLoadedRequest { string path = 1; bytes content = 2; }
message OnContentLoadedResponse { bytes content = 1; }
.PP
message OnContentRenderRequest { string path = 1; bytes content = 2; }
message OnContentRenderResponse { bytes content = 1; }
.PP
message OnHTMLRenderedRequest { string path = 1; bytes content = 2; }
message OnHTMLRenderedResponse { bytes content = 1; }
.PP
message OnPostBuildRequest {} message OnPostBuildResponse {}
